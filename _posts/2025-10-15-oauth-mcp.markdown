---
layout: post
title:  "No More Tokens: Why Every Hosted MCP Server Needs OAuth"
date:   2025-10-15 08:17:10 -0400
categories: jekyll update
tag: [oauth, mcp]
---

## The Problem: Tokens Don’t Scale

If you’ve ever connected a hosted **MCP (Model Context Protocol) server** to tools like **ChatGPT**, **Claude Desktop**, or **Copilot**, you’ve probably felt the pain:

- Copying access tokens by hand.  
- Managing token rotation and expiry.  
- Worrying about leaks in logs or environment variables.  
- Explaining to users why “enter your secret key” is still a thing in 2025.

In short — manual tokens are **insecure**, **unscalable**, and **unfriendly**.  
OAuth solves all of that.

---

## The Solution: OAuth for Hosted MCP Servers

**OAuth 2.0** is the industry standard for **secure, delegated authorization**.  
It lets users connect applications safely — without ever sharing passwords or long-lived tokens.

For a **hosted MCP server**, enabling OAuth means:

- ✅ **Instant sign-in experience** — users click “Connect” and authorize via Google, GitHub, or SSO.  
- ✅ **No manual token management** — short-lived, auto-refreshed access tokens.  
- ✅ **Granular permissions** — only the scopes you need (`mcp.read`, `mcp.write`, etc.).  
- ✅ **Auditable & revocable** — users can revoke access at any time via their identity provider.  

This is how every modern API — from Google to Slack — secures third-party integrations.

---

## How It Works

When ChatGPT (or Claude Desktop) connects to your hosted MCP server, it should see that the server supports OAuth:

```json
{
  "auth": {
    "type": "oauth2",
    "authorization_endpoint": "https://your-mcp-server.com/login",
    "token_endpoint": "https://your-mcp-server.com/token",
    "scopes": ["openid", "profile", "mcp.api"]
  }
}
```

From there:

1. The user clicks **"Authorize"**.
2. The browser opens your identity provider (Google, Auth0, Azure AD).
3. The user signs in and grants access.
4. The client (ChatGPT or Claude) receives a short-lived **Access Token**.
5. It uses that token to talk to your MCP server's API.

No secrets. No manual steps. Just secure, auditable authorization.

---

## OAuth Integration Architecture

The following diagram illustrates the architecture of an MCP server with OAuth integration:

```mermaid
flowchart TD
    User[User] <--> AIAssistant[AI Assistant\nChatGPT/Claude]
    AIAssistant <--> MCPServer[MCP Server]
    MCPServer <--> Tools[Tool Registry]
    MCPServer <--> ExternalSystems[External Systems]
    
    AIAssistant <--> AuthFlow[OAuth Flow]
    AuthFlow <--> IdP[Identity Provider\nAuth0/Google/Azure AD]
    IdP <--> UserAuth[User Authentication]
    
    MCPServer <--> TokenValidator[Token Validator]
    TokenValidator <--> IdP
    
    subgraph "Security Layer"
        AuthFlow
        TokenValidator
        IdP
    end
    
    subgraph "MCP Infrastructure"
        MCPServer
        Tools
        ExternalSystems
    end
    
    classDef auth fill:#f9f,stroke:#333,stroke-width:2px
    classDef mcp fill:#bbf,stroke:#333,stroke-width:1px
    classDef user fill:#dfd,stroke:#333,stroke-width:1px
    
    class AuthFlow,TokenValidator,IdP,UserAuth auth
    class MCPServer,Tools,ExternalSystems mcp
    class User,AIAssistant user
```

### Key Components

1. **AI Assistant**: ChatGPT or Claude Desktop that needs to connect to the MCP server
2. **MCP Server**: Your hosted server implementing the Model Context Protocol
3. **Identity Provider (IdP)**: OAuth provider like Auth0, Google, or Azure AD
4. **OAuth Flow**: Handles the authorization code exchange process
5. **Token Validator**: Verifies access tokens with the IdP
6. **Tool Registry**: Contains the tools available through your MCP server
7. **External Systems**: Backend services that your tools interact with

### Security Boundaries

The OAuth integration creates clear security boundaries:
- User identity is verified by a trusted third party
- Access tokens have limited scope and lifetime
- The MCP server never sees user credentials
- Token validation happens on every request

---

## OAuth Integration Workflow

The following sequence diagram shows the detailed OAuth flow for MCP server integration:

```mermaid
sequenceDiagram
    participant User
    participant AIAssistant as AI Assistant
    participant MCPServer as MCP Server
    participant IdP as Identity Provider
    participant ExternalSystems as External Systems
    
    User->>AIAssistant: Connect to MCP Server
    AIAssistant->>MCPServer: Discover auth requirements
    MCPServer-->>AIAssistant: Return OAuth configuration
    
    AIAssistant->>User: Request authorization
    User->>AIAssistant: Approve connection
    
    AIAssistant->>IdP: Initiate OAuth flow
    IdP->>User: Present login screen
    User->>IdP: Authenticate & authorize
    IdP->>AIAssistant: Return authorization code
    
    AIAssistant->>IdP: Exchange code for tokens
    IdP-->>AIAssistant: Return access & refresh tokens
    
    AIAssistant->>MCPServer: API request with access token
    MCPServer->>IdP: Validate token
    IdP-->>MCPServer: Token validation result
    
    alt Valid Token
        MCPServer->>ExternalSystems: Execute tool operation
        ExternalSystems-->>MCPServer: Return results
        MCPServer-->>AIAssistant: Return API response
        AIAssistant-->>User: Present results
    else Invalid Token
        MCPServer-->>AIAssistant: Authentication error
        AIAssistant->>IdP: Request token refresh
        IdP-->>AIAssistant: New access token
        Note over AIAssistant,MCPServer: Retry request with new token
    end
    
    Note over User,ExternalSystems: Token refresh happens automatically
```

### Key Workflow Phases

1. **Discovery**: AI assistant discovers the MCP server requires OAuth
2. **Authorization**: User approves the connection through the IdP
3. **Token Exchange**: Authorization code is exchanged for access tokens
4. **Authenticated Requests**: All API calls include the access token
5. **Token Validation**: Server validates tokens on each request
6. **Token Refresh**: Expired tokens are automatically refreshed

### Token Lifecycle

```mermaid
stateDiagram-v2
    [*] --> Requested
    Requested --> Authorized: User approves
    Authorized --> Active: Code exchanged
    Active --> Expired: After timeout
    Expired --> Refreshed: Using refresh token
    Refreshed --> Active
    Active --> Revoked: User revokes
    Expired --> Revoked: Refresh fails
    Revoked --> [*]
    
    note right of Active
        Typical lifetime: 1 hour
    end note
    
    note right of Refreshed
        Can happen silently
        without user interaction
    end note
```

---

## Implementation Sketch (FastAPI Example)

A minimal Python implementation using **FastAPI + Authlib** might look like this:

```python
from fastapi import FastAPI, Request
from fastapi.responses import RedirectResponse, JSONResponse
from authlib.integrations.starlette_client import OAuth

app = FastAPI()
oauth = OAuth()

auth0 = oauth.register(
    name="auth0",
    client_id="YOUR_CLIENT_ID",
    client_secret="YOUR_CLIENT_SECRET",
    server_metadata_url="https://your-tenant.us.auth0.com/.well-known/openid-configuration",
    client_kwargs={"scope": "openid profile email"},
)

@app.get("/login")
async def login(request: Request):
    redirect_uri = "https://your-mcp-server.com/callback"
    return await oauth.auth0.authorize_redirect(request, redirect_uri)

@app.get("/callback")
async def callback(request: Request):
    token = await oauth.auth0.authorize_access_token(request)
    userinfo = token.get("userinfo")
    return JSONResponse(userinfo)
```

That’s it — your hosted MCP server is now OAuth-enabled.  
Clients connect securely, and tokens are managed automatically.

---

## Design Considerations

| Concern | Best Practice |
|----------|----------------|
| **Token Lifetime** | Keep Access Tokens short (e.g. 1 hour). Use Refresh Tokens for silent renewal. |
| **Scope Design** | Define minimal scopes: `mcp.read`, `mcp.write`, `mcp.admin`. |
| **Storage** | Never store tokens client-side. Keep them encrypted server-side. |
| **Revocation** | Expose `/oauth/revoke` to let users disconnect any time. |
| **SSO / MFA** | Integrate with enterprise IdPs (Azure AD, Okta, Google Workspace). |

---

## The Payoff

- **Developers love it** — zero friction when connecting AI tools.  
- **Security teams approve it** — full compliance with enterprise auth standards.  
- **Easier scaling** — one identity layer, infinite MCP instances.  
- **Future-proof** — works seamlessly with ChatGPT, Claude, and any future AI client supporting OAuth.

---

## In Short

> If your hosted MCP server still asks for a token, you’re doing 2023 security in 2025.

OAuth isn’t just “nice to have” — it’s **table stakes** for secure, enterprise-ready MCP integrations.  
Enable it once, and every AI client can connect safely with a single click.

---

## For Architects

| Feature | Token-Based | OAuth 2.0 |
|----------|--------------|-----------|
| Setup | Manual | One-click |
| Security | Weak | Strong |
| Revocation | None | Built-in |
| SSO / MFA | No | Yes |
| UX | Clunky | Seamless |

---

## Next Steps

- Enable **OAuth 2.0 Authorization Code + PKCE** in your hosted MCP server.  
- Register your app with your chosen IdP (Auth0, Azure, Okta, Google).  
- Expose `/login`, `/callback`, `/token`, and `/revoke` endpoints.  
- Update your `.well-known/mcp-manifest.json` to advertise OAuth support.

Once done, ChatGPT or Claude Desktop will **auto-detect and authenticate** — no more tokens required.

---

## Example Manifest Snippet

```json
{
  "name": "Hosted MCP Server with OAuth",
  "version": "1.0.0",
  "auth": {
    "type": "oauth2",
    "authorization_endpoint": "https://your-mcp-server.com/login",
    "token_endpoint": "https://your-mcp-server.com/token",
    "scopes": ["openid", "profile", "mcp.api"]
  }
}
```